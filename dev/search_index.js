var documenterSearchIndex = {"docs":
[{"location":"#GeoAACGM.jl","page":"Home","title":"GeoAACGM.jl","text":"","category":"section"},{"location":"#GeoAACGM","page":"Home","title":"GeoAACGM","text":"GeoAACGM\n\nA pure Julia implementation of the Altitude-Adjusted Corrected Geomagnetic (AACGM) coordinate system to trace magnetic field lines for ionospheric and magnetospheric research.\n\nSimple, fast, and accurate.\n\nWe support coordinate transformations between the following coordinate systems:\n\nAACGM: (mlat [deg], mlon [deg], r [Earth radii]),   based on the IGRF-14 model (1900-2030)   and GUFM1 model (1590-1900).\nGeocentric: (lat [deg], lon [deg], height [km])\nGeodetic: (lat [deg], lon [deg], height [km]), based on the WGS84 ellipsoid model of the Earth.\n\nwith geoc2aacgm, geod2aacgm, geod2geoc functions.\n\nExamples\n\nusing GeoAACGM, Dates\n\ndt = DateTime(2029, 3, 22, 3, 11);\nglat, glon, height = 45.5, -23.5, 1135;\n\n# Convert geocentric to AACGM\nmlat, mlon, r = geoc2aacgm(glat, glon, height, dt)\n\n# Convert geodetic to AACGM\nmlat, mlon, r = geod2aacgm(glat, glon, height, dt)\n\nReferences\n\nAACGM-V2\naacgmv2:   Python library for AACGM-v2 magnetic coordinates GitHub\n\n\n\n\n\n","category":"module"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"GeoAACGM\")","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"#Exported-functions","page":"Home","title":"Exported functions","text":"","category":"section"},{"location":"#GeoAACGM.aacgm2geoc","page":"Home","title":"GeoAACGM.aacgm2geoc","text":"aacgm2geoc(mlat, mlon, r, time / coefs, order)\n\nConvert AACGM coordinates (mlat [deg], mlon [deg], r [Earth radii]) to geocentric coordinates (lat [deg], lon [deg], height [km]).\n\n\n\n\n\n","category":"function"},{"location":"#GeoAACGM.aacgm2geod-Tuple{Any, Any, Any, Vararg{Any}}","page":"Home","title":"GeoAACGM.aacgm2geod","text":"aacgm2geod(mlat, mlon, r, time / coefs)\n\nConvert AACGM coordinates (mlat [deg], mlon [deg], r [Earth radii]) to geodetic coordinates (lat [deg], lon [deg], height [km]).\n\n\n\n\n\n","category":"method"},{"location":"#GeoAACGM.geo2aacgm-NTuple{4, Any}","page":"Home","title":"GeoAACGM.geo2aacgm","text":"geo2aacgm(x, y, z, time)\n\nConvert (x [km], y [km], z [km]) in geocentric geographic (cartesian) coordinates to (mlat [deg], mlon [deg], r [Earth radii]) in AACGM coordinate.\n\n\n\n\n\n","category":"method"},{"location":"#GeoAACGM.geoc2aacgm","page":"Home","title":"GeoAACGM.geoc2aacgm","text":"geoc2aacgm(lat, lon, height, time, ...) -> (mlat, mlon, r)\ngeoc2aacgm(lat, lon, height, coefs=geo2aacgm_coefs[], ...) -> (mlat, mlon, r)\n\nConvert between geocentric (lat [deg], lon [deg], height [km]) and AACGM coordinates (mlat [deg], mlon [deg], r [Earth radii]) using spherical harmonic expansion.\n\nSimilar to the C function convert_geo_coord_v2.\n\n\n\n\n\n","category":"function"},{"location":"#GeoAACGM.geoc2geod-Tuple{Any, Any, Any}","page":"Home","title":"GeoAACGM.geoc2geod","text":"geoc2geod(lat, lon, r)\n\nConvert geocentric coordinates to geodetic coordinates. This is part of the coordinate transformation pipeline in AACGM-v2.\n\nReturns\n\n(lat_geod, lon, height): Geodetic coordinates (latitude in degrees, longitude in degrees, height in km)\n\n\n\n\n\n","category":"method"},{"location":"#GeoAACGM.geod2aacgm-Tuple{Any, Any, Any, Vararg{Any}}","page":"Home","title":"GeoAACGM.geod2aacgm","text":"geod2aacgm(lat, lon, height, time / coefs)\n\nConvert geodetic coordinates (lat [deg], lon [deg], height [km]) to AACGM coordinates (mlat [deg], mlon [deg], r [Earth radii]).\n\nSimilar to the C function AACGM_v2_Convert.\n\n\n\n\n\n","category":"method"},{"location":"#GeoAACGM.geod2geoc-Tuple{Any, Any, Any}","page":"Home","title":"GeoAACGM.geod2geoc","text":"geod2geoc(lat, lon, alt)\n\nConvert geodetic coordinates to geocentric coordinates.\n\n\n\n\n\n","category":"method"},{"location":"#Private-functions","page":"Home","title":"Private functions","text":"","category":"section"},{"location":"#GeoAACGM.aacgm2alt-Tuple{Any, Any}","page":"Home","title":"GeoAACGM.aacgm2alt","text":"aacgm2alt(hgt, lat)\n\nTransformation from AACGM to so-called 'at-altitude' coordinates.\n\nThe purpose of this function is to scale the latitudes in such a way that there is no gap. The problem is that for non-zero altitudes (h) are range of latitudes near the equator     lie on dipole field lines that near reach the altitude h, and are therefore not accessible. This mapping closes the gap.\n\ncos (lat_at-alt) = sqrt( (Re + h)/Re ) cos (lat_aacgm)\n\nSimilar to the C function AACGM_v2_CGM2Alt.\n\n\n\n\n\n","category":"method"},{"location":"#GeoAACGM.cart2sph-Tuple{Any, Any, Any}","page":"Home","title":"GeoAACGM.cart2sph","text":"cart2sph(x, y, z)\n\nConvert (x, y, z) in Cartesian coordinate to (r, lat [deg], lon [deg]) in spherical coordinate.\n\n\n\n\n\n","category":"method"},{"location":"#GeoAACGM.compute_harmonics!-NTuple{4, Any}","page":"Home","title":"GeoAACGM.compute_harmonics!","text":"compute_harmonics!(S, colat, lon, order)\n\nCompute spherical harmonic function values Ylm(colat, lon) up to given order. This is equivalent to the C function `AACGMv2_Rylm`.\n\nReturn a vector of spherical harmonic values with indexing k = l*(l+1) + m + 1.\n\n\n\n\n\n","category":"method"},{"location":"#GeoAACGM.get_coefficient_path-Tuple{Any}","page":"Home","title":"GeoAACGM.get_coefficient_path","text":"get_coefficient_path(year)\n\nDetermine the path to the coefficient file for a given year. AACGM coefficients are provided in 5-year epochs.\n\n\n\n\n\n","category":"method"},{"location":"#GeoAACGM.load_coefficients-Tuple{Any}","page":"Home","title":"GeoAACGM.load_coefficients","text":"load_coefficients(year)\n\nLoad AACGM coefficient files for the specified year (1590-2025).\n\nCoefficients are organized in 5-year epochs.\n\n\n\n\n\n","category":"method"},{"location":"#Validation-and-Benchmark","page":"Home","title":"Validation and Benchmark","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"note: Note\nIt is preferable to use the geo2aacgm.(glats, glons, hights, times) interface compared to manually setting the coefficients with set_coefficients! and then using geo2aacgm(glat, glon, hight). The former is simpler and ensures accuracy with negligible performance loss due to lazy interpolation.","category":"page"},{"location":"#Single-Time-Conversion","page":"Home","title":"Single Time Conversion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using GeoAACGM, LibAACGM\nusing Dates\nusing Test, Chairmarks\n\n# Helper function to compare element-wise\nis_approx_v(x, y; kw...) = length(x) == 1 ? isapprox(x, y; kw...) : all(is_approx_v.(x, y; kw...))\n\nlat, lon, hgt = 45.5, -23.5, 1135\ndt = DateTime(2029, 3, 22, 3, 11)\n\nLibAACGM.AACGM_v2_SetDateTime(dt)\nc_result = LibAACGM.AACGM_v2_Convert(lat, lon, hgt, 0)\nset_coefficients!(dt)\njl_result = geod2aacgm(lat, lon, hgt, dt)\n\n# Validation\n@assert is_approx_v(jl_result, c_result, atol=1e-4)\n# Benchmark\n@b geod2aacgm(lat, lon, hgt, dt), geod2aacgm(lat, lon, hgt), LibAACGM.AACGM_v2_Convert(lat, lon, hgt, 0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Julia implementation yields results comparable to the C implementation but runs approximately twice as fast (for preset coefficients).  The slight discrepancy in the output arises from Juliaâ€™s use of a more precise interpolation of the coefficients compared to that used in the C version.","category":"page"},{"location":"#Multiple-Time-Conversion","page":"Home","title":"Multiple Time Conversion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When times are close to each other, it may be faster to set the time just once and perform the coordinate transformation multiple times.","category":"page"},{"location":"","page":"Home","title":"Home","text":"n = 10\nglats = 45 .+ rand(n)\nglons = -23 .+ rand(n)\nhights = 1000 .+ 10 * rand(n)\ndts = dt .+ Second.(rand(Int8, n))\n\nset_coefficients!(dt)\nres1 = geoc2aacgm.(glats, glons, hights, dts)\nres2 = geoc2aacgm.(glats, glons, hights)\n\n@assert is_approx_v(res1, res2; atol=1e-6)\n@b geoc2aacgm.(glats, glons, hights, dts), geoc2aacgm.(glats, glons, hights)","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, for far-apart times, it is better to use the exact time for each conversion. And lazy interpolation provides a performance boost.","category":"page"},{"location":"","page":"Home","title":"Home","text":"dts = dt .+ Second.(rand(Int16, n))\n\nres1 = geoc2aacgm.(glats, glons, hights, dts)\nres2 = geoc2aacgm.(glats, glons, hights)\n\n# Results are not the same, it is better to set the datetime for each conversion\n@test !is_approx_v(res1, res2) \n\nslow_geoc2aacgm(glat, glon, hight, dt) = begin\n    set_coefficients!(dt)\n    geoc2aacgm(glat, glon, hight)\nend\n\n@assert is_approx_v(geoc2aacgm.(glats, glons, hights, dts), slow_geoc2aacgm.(glats, glons, hights, dts))\n@b geoc2aacgm.(glats, glons, hights, dts), slow_geoc2aacgm.(glats, glons, hights, dts)","category":"page"}]
}
